%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 3acd6fe57257048db802c1c4c2b75248, type: 3}
  m_Name: WorldBuilding
  m_EditorClassIdentifier: 
  shaderName: WorldBuilding
  shaderReference: {fileID: 4800000, guid: 2ef7d3d32af0c0f4787595286b578650, type: 3}
  shaderTemplate: uRaymarching/Deferred/Standard
  variables:
  - key: Name
    value: WorldBuilding
  - key: ObjectShape
    value: NONE
  - key: RaymarchingShaderDirectory
    value: Assets\uRaymarching\Shaders\Include\Legacy
  - key: RenderType
    value: Opaque
  - key: RenderQueue
    value: Geometry
  conditions:
  - key: ShadowCaster
    value: 0
  - key: FullScreen
    value: 1
  - key: WorldSpace
    value: 1
  - key: FollowObjectScale
    value: 0
  - key: CameraInsideObject
    value: 1
  - key: UseRaymarchingDepth
    value: 1
  - key: FallbackToDiffuse
    value: 0
  - key: Blend
    value: 0
  - key: UseCameraDepthTexture
    value: 0
  - key: DisableViewCulling
    value: 0
  - key: SphericalHarmonicsPerPixel
    value: 1
  - key: UseGrabPass
    value: 0
  - key: ForwardAdd
    value: 0
  - key: FallbackToStandardShader
    value: 0
  blocks:
  - key: Properties
    value: "        [Header(World)]\n        _BuildingRepeat (\"Building Repeat\",
      Vector) = (20, 20, 20, 1)\n        _IfsLoop (\"Ifs Loop\", Range(1, 10)) =
      5\n        _BuildingOffset (\"Building Offset\", Vector) = (0, 0, 0, 1)\n       
      _RotateXY1 (\"_RotateXY1\", Range(-4, 4)) = 0.3\n        _RotateXZ1 (\"_RotateXZ1\",
      Range(-4, 4)) = -0.1\n        _RotateYZ1 (\"_RotateYZ1\", Range(-4, 4)) = -0.1\n       
      _FoldRotate (\"Fold Rotate\", Range(1, 20)) = 6\n        _BuildingBoxSize (\"Building
      Box Size\", Vector) = (5, 0.5, 0.5, 1)\n        _EvilScale (\"Evil Scale\",
      Range(0, 2)) = 1.1\n        [HDR] _EmissionColor (\"Emission Color\", Color)
      = (1, 1, 1, 1)"
    folded: 0
  - key: DistanceFunction
    value: "        #include \"Common.cginc\"\n\n        float3 _BuildingRepeat;\n       
      float _IfsLoop;\n        float4 _BuildingOffset;\n        float _RotateXY1;\n       
      float _RotateXZ1;\n        float _RotateYZ1;\n        float3 _BuildingBoxSize;\n       
      float _EvilScale;\n        float4 _EmissionColor;\n\n        inline float DistanceFunction(float3
      pos)\n        {\n            float3 p = pos;\n\n            p = Repeat(p, _BuildingRepeat);\n\n           
      float3 size = _BuildingBoxSize;\n            float d = sdBox(p, size);\n\n           
      return d;\n        }"
    folded: 0
  - key: PostEffect
    value: "        #define map DistanceFunction\n\n        // https://www.shadertoy.com/view/lttGDn\n       
      float calcEdge(float3 p)\n        {\n            float edge = 0.0;\n           
      float2 e = float2(.1, 0);\n\n            // Take some distance function measurements
      from either side of the hit point on all three axes.\n            float d1
      = map(p + e.xyy), d2 = map(p - e.xyy);\n            float d3 = map(p + e.yxy),
      d4 = map(p - e.yxy);\n            float d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n           
      float d = map(p) * 2.;\t// The hit point itself - Doubled to cut down on calculations.
      See below.\n\n            // Edges - Take a geometry measurement from either
      side of the hit point. Average them, then see how\n            // much the
      value differs from the hit point itself. Do this for X, Y and Z directions.
      Here, the sum\n            // is used for the overall difference, but there
      are other ways. Note that it's mainly sharp surface\n            // curves
      that register a discernible difference.\n            edge = abs(d1 + d2 - d)
      + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n            //edge = max(max(abs(d1
      + d2 - d), abs(d3 + d4 - d)), abs(d5 + d6 - d)); // Etc.\n\n            //
      Once you have an edge value, it needs to normalized, and smoothed if possible.
      How you\n            // do that is up to you. This is what I came up with for
      now, but I might tweak it later.\n            edge = smoothstep(0., 1., sqrt(edge
      / e.x * 2.));\n\n            // Return the normal.\n            // Standard,
      normalized gradient mearsurement.\n            return edge;\n        }\n\n       
      float random(float2 st)\n        {\n            return frac(sin(dot(st.xy,\n           
      float2(12.9898, 78.233))) *\n            43758.5453123);\n        }\n\n       
      float noise(in float2 st)\n        {\n            float2 i = floor(st);\n           
      float2 f = frac(st);\n            // Four corners in 2D of a tile\n           
      float a = random(i);\n            float b = random(i + float2(1.0, 0.0));\n           
      float c = random(i + float2(0.0, 1.0));\n            float d = random(i + float2(1.0,
      1.0));\n            // Smooth Interpolation\n            // Cubic Hermine Curve. 
      Same as SmoothStep()\n            float2 u = f * f * (3.0 - 2.0 * f);\n           
      // u = smoothstep(0.,1.,f);\n            // lerp 4 coorners percentages\n           
      return lerp(a, b, u.x) +\n            (c - a) * u.y * (1.0 - u.x) +\n           
      (d - b) * u.x * u.y;\n        }\n\n        float maxabs(float2 p)\n       
      {\n            return max(abs(p.x), abs(p.y));\n        }\n\n        float
      voronoi(float2 uv)\n        {\n            float2 i = floor(uv);\n           
      float2 f = frac(uv);\n            float2 res = float2(8.0, 8);\n\n           
      for (int x = -1; x <= 1; x++)\n            {\n                for (int y =
      -1; y <= 1; y++)\n                {\n                    float2 n = float2(x,
      y);\n                    float2 np = float2(random(i + n), random(i + n + float2(12.56,
      64.66)));\n                    float2 p = n + np - f;\n                   
      float d = abs(p.x) + abs(p.y);\n                    if (d < res.x)\n                   
      {\n                        res.y = res.x;\n                        res.x =
      d;\n                    }\n                    else if (d < res.y)\n                   
      {\n                        res.y = d;\n                    }\n               
      }\n            }\n\n            float c = res.y - res.x;\n            c = sqrt(c);\n           
      c = smoothstep(0.4, 0.0, c);\n            return c;\n        }\n\n        inline
      void PostEffect(RaymarchInfo ray, inout PostEffectOutput o)\n        {\n           
      // float edge = calcEdge(ray.endPos) * saturate(cos(_Beat * TAU - Mod(0.1 *
      ray.endPos.z, TAU)));\n\n            o.Emission = _EmissionColor * voronoi(ray.endPos.xz);\n       
      }"
    folded: 0
  constants: {fileID: 11400000, guid: b54b57bcc672e49638fe9b2da609c4df, type: 2}
  basicFolded: 1
  conditionsFolded: 0
  variablesFolded: 0
  materialsFolded: 0
  constantsFolded: 0
