%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 3acd6fe57257048db802c1c4c2b75248, type: 3}
  m_Name: WorldBuilding
  m_EditorClassIdentifier: 
  shaderName: WorldBuilding
  shaderReference: {fileID: 4800000, guid: 2ef7d3d32af0c0f4787595286b578650, type: 3}
  shaderTemplate: uRaymarching/Deferred/Standard
  variables:
  - key: Name
    value: WorldBuilding
  - key: ObjectShape
    value: NONE
  - key: RaymarchingShaderDirectory
    value: Assets\uRaymarching\Shaders\Include\Legacy
  - key: RenderType
    value: Opaque
  - key: RenderQueue
    value: Geometry
  conditions:
  - key: ShadowCaster
    value: 0
  - key: FullScreen
    value: 1
  - key: WorldSpace
    value: 1
  - key: FollowObjectScale
    value: 0
  - key: CameraInsideObject
    value: 1
  - key: UseRaymarchingDepth
    value: 1
  - key: FallbackToDiffuse
    value: 0
  - key: Blend
    value: 0
  - key: UseCameraDepthTexture
    value: 0
  - key: DisableViewCulling
    value: 0
  - key: SphericalHarmonicsPerPixel
    value: 1
  - key: UseGrabPass
    value: 0
  - key: ForwardAdd
    value: 0
  - key: FallbackToStandardShader
    value: 0
  blocks:
  - key: Properties
    value: "        [Header(World)]\n        _HexagonRadians (\"Hexagon Radians\",
      Range(0, 5)) = 1\n        _HexagonPadding (\"Hexagon Padding\", Range(0, 1))
      = 0.1\n        [HDR] _EmissionColor (\"Emission Color\", Color) = (1, 1, 1,
      1)"
    folded: 0
  - key: DistanceFunction
    value: "        #include \"Common.cginc\"\n\n        float _HexagonRadians;\n       
      float _HexagonPadding;\n        float4 _EmissionColor;\n\n        float dHexagon(float3
      p)\n        {\n            p.xz = foldRotate(p.xz, 6);\n            return
      sdBox(p, float3(_HexagonRadians, 1, _HexagonRadians));\n        }\n\n       
      inline float DistanceFunction(float3 pos)\n        {\n            float3 p
      = pos;\n\n            float pitch = _HexagonRadians * 2 + _HexagonPadding;\n           
      float sqrt3_div_2 = 0.8660254037844386467637231707529361834714026269051903140279034897;\n           
      float3 offset = float3(pitch * sqrt3_div_2, 0, pitch * 0.5);\n            float3
      loop = float3(offset.x * 2, 10, offset.z * 2);\n            \n            float3
      p1 = p;\n            float3 p2 = p + offset;\n\n            // calculate indices\n           
      float2 pi1 = floor(p1 / loop).xz;\n            float2 pi2 = floor(p2 / loop).xz;\n           
      pi1.y = pi1.y * 2;\n            pi2.y = pi2.y * 2 + 1;\n\n            p1.y
      += 0.3 * sin(10 * Rand(pi1) + 0.1 * TAU * _Beat);\n            p2.y += 0.3
      * sin(10 * Rand(pi2) + 0.1 * TAU * _Beat);\n            p1 = Repeat(p1, loop);\n           
      p2 = Repeat(p2, loop);\n\n            float d = dHexagon(p1);\n           
      d = min(d, dHexagon(p2));\n\n            return d;\n        }"
    folded: 0
  - key: PostEffect
    value: "        #define map DistanceFunction\n\n        // https://www.shadertoy.com/view/lttGDn\n       
      float calcEdge(float3 p)\n        {\n            float edge = 0.0;\n           
      float2 e = float2(.01, 0);\n\n            // Take some distance function measurements
      from either side of the hit point on all three axes.\n            float d1
      = map(p + e.xyy), d2 = map(p - e.xyy);\n            float d3 = map(p + e.yxy),
      d4 = map(p - e.yxy);\n            float d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n           
      float d = map(p) * 2.;\t// The hit point itself - Doubled to cut down on calculations.
      See below.\n\n            // Edges - Take a geometry measurement from either
      side of the hit point. Average them, then see how\n            // much the
      value differs from the hit point itself. Do this for X, Y and Z directions.
      Here, the sum\n            // is used for the overall difference, but there
      are other ways. Note that it's mainly sharp surface\n            // curves
      that register a discernible difference.\n            edge = abs(d1 + d2 - d)
      + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n            //edge = max(max(abs(d1
      + d2 - d), abs(d3 + d4 - d)), abs(d5 + d6 - d)); // Etc.\n\n            //
      Once you have an edge value, it needs to normalized, and smoothed if possible.
      How you\n            // do that is up to you. This is what I came up with for
      now, but I might tweak it later.\n            edge = smoothstep(0., 1., sqrt(edge
      / e.x * 2.));\n\n            // Return the normal.\n            // Standard,
      normalized gradient mearsurement.\n            return edge;\n        }\n\n       
      float random(float2 st)\n        {\n            return frac(sin(dot(st.xy,
      float2(12.9898, 78.233))) * 43758.5453123);\n        }\n\n        float noise(in
      float2 st)\n        {\n            float2 i = floor(st);\n            float2
      f = frac(st);\n            \n            // Four corners in 2D of a tile\n           
      float a = random(i);\n            float b = random(i + float2(1.0, 0.0));\n           
      float c = random(i + float2(0.0, 1.0));\n            float d = random(i + float2(1.0,
      1.0));\n            \n            // Smooth Interpolation\n            // Cubic
      Hermine Curve.  Same as SmoothStep()\n            float2 u = f * f * (3.0 -
      2.0 * f);\n            \n            // u = smoothstep(0.,1.,f);\n           
      // lerp 4 coorners percentages\n            return lerp(a, b, u.x) + (c - a)
      * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n        }\n\n        // \u30DE\u30F3\u30CF\u30C3\u30BF\u30F3\u8DDD\u96E2\u306B\u3088\u308B\u30DC\u30ED\u30CE\u30A4\n       
      float voronoi(float2 uv)\n        {\n            float2 i = floor(uv);\n           
      float2 f = frac(uv);\n            float2 res = float2(8, 8);\n\n           
      for (int x = -1; x <= 1; x++)\n            {\n                for (int y =
      -1; y <= 1; y++)\n                {\n                    float2 n = float2(x,
      y);\n                    float2 np = float2(random(i + n), random(i + n + float2(12.56,
      64.66)));\n                    float2 p = n + np - f;\n                   
      float d = abs(p.x) + abs(p.y);\n\n                    if (d < res.x)\n                   
      {\n                        res.y = res.x;\n                        res.x =
      d;\n                    }\n                    else if (d < res.y)\n                   
      {\n                        res.y = d;\n                    }\n               
      }\n            }\n\n            float c = res.y - res.x;\n            c = sqrt(c);\n           
      c = smoothstep(0.3, 0.0, c);\n            return c;\n        }\n\n        inline
      void PostEffect(RaymarchInfo ray, inout PostEffectOutput o)\n        {\n           
      // FIXME: Common\u5B9A\u7FA9\n            float edge = calcEdge(ray.endPos);//
      * saturate(cos(_Beat * TAU - Mod(0.1 * ray.endPos.z, TAU)));\n\n           
      edge += 0.1 * (voronoi(ray.endPos.xz) + 0.5 * voronoi(ray.endPos.xz * 2.0));\n\n           
      o.Emission = _EmissionColor * edge;\n        }"
    folded: 0
  constants: {fileID: 11400000, guid: b54b57bcc672e49638fe9b2da609c4df, type: 2}
  basicFolded: 1
  conditionsFolded: 0
  variablesFolded: 0
  materialsFolded: 0
  constantsFolded: 0
